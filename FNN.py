import os
import csv

from tqdm import tqdm
import torch
from torch.utils.data import Dataset
import torchvision

from processor import get_feature_vector


class CustomDataset(Dataset):
    def __init__(self):
        self.x = []
        self.t = []
        with open(r'Project_directory\Malware_BMI\train.csv', 'r') as f:
            csv_data = csv.reader(f)
            for row in csv_data:
                self.x.append(row[0])
                self.t.append([int(row[1])])

    def __len__(self):
        return len(self.x)

    def __getitem__(self, item):
        x = get_feature_vector(self.x[item])
        t = self.t[item]
        x = torch.FloatTensor(x)
        t = torch.FloatTensor(t)
        return x, t


class FNN(torch.nn.Module):
    def __init__(self):
        super(FNN, self).__init__()

        self.layer1 = torch.nn.Sequential(
            torch.nn.Linear(11, 121),
            torch.nn.ReLU(),
            torch.nn.Linear(121, 11),
            torch.nn.ReLU(),
        )

        self.classifier = torch.nn.Sequential(
            torch.nn.Linear(11, 1),
            torch.nn.Sigmoid()
        )

    def forward(self, x):
        out = self.layer1(x)
        out = self.classifier(out)
        return out


def main():
    device = 'cuda' if torch.cuda.is_available() else 'cpu'

    # hyper parameter
    learning_rate = 0.001
    training_epoch = 20
    batch_size = 10

    model = FNN().to(device)
    criterion = torch.nn.BCELoss().to(device)
    optimizer = torch.optim.AdamW(model.parameters(), lr=learning_rate)

    print("Learning Start")
    train_set = CustomDataset()
    train_data = torch.utils.data.DataLoader(train_set, batch_size=batch_size, shuffle=True, num_workers=4)
    model.train()
    for epoch in range(training_epoch):
        print("Epoch %s start" % (epoch + 1))
        avg_cost = 0
        for data in tqdm(train_data):
            features, labels = data
            features = features.to(device)
            labels = labels.to(device)
            prediction = model(features)
    
            optimizer.zero_grad()
            cost = criterion(prediction, labels)
            cost.backward()
            optimizer.step()
    
            avg_cost += cost / len(train_data)
        print('cost :', float(avg_cost))
    print("Leaning Finish")
    
    torch.save(model, r'Project_directory\Malware_BMI\model.pth')

    model = torch.load(r'Project_directory\Malware_BMI\model.pth')
    print("Test Start")
    test_set = CustomDataset()
    test_data = torch.utils.data.DataLoader(test_set, batch_size=len(test_set), shuffle=True)
    model.eval()

    with torch.no_grad():
        correct = 0
        correct_recall = 0
        mal = 0
        for data in tqdm(test_data):
            features, labels = data
            features = features.to(device)
            labels = labels.to(device)
            prediction = model(features)
            for i in range(len(prediction)):
                if prediction[i] < 0.5:
                    prediction[i] = 0
                else:
                    prediction[i] = 1

                if prediction[i] == labels[i]:
                    correct += 1
                    if prediction[i] == 1:
                        correct_recall += 1
                        mal += 1
                elif labels[i] == 1:
                    mal += 1

        print("Acc :", correct / len(test_set))
        print("Recall :", correct_recall / mal)


if __name__ == '__main__':
    main()
